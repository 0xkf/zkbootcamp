宿題の算数2

1)
モジュラ算法：奇数正方形（mod 8）と偶数正方形（mod 8)
すべての奇数正方形が1（mod 8）に合同であるかどうかを判断するために、いくつかの例を検証してみましょう：

xを奇数整数とすると、x＝2n＋1、nは整数である。
xの2乗であるx^2 = (2n + 1)^2 = 4n^2 + 4n + 1
=4n(n+1)+1　n(n+1)は、どちらかが偶数なので８の倍数。よって、合同。

では、奇数の整数をテストしてみましょう：
奇数の二乗はすべて≡1（mod 8）であると思われます。



偶数乗（mod 8）の場合、yを偶数整数とすると、y＝2m（mは整数）である。
yの2乗、y^2 = (2m)^2 = 4m^2。

では、偶数の整数をテストしてみましょう：

2^2 = 4 ≡ 4 (mod 8)
4^2 = 16 ≡ 0 (mod 8)
6^2 = 36 ≡ 4 (mod 8)
8^2 = 64 ≡ 0 (mod 8)
これらの例から、偶数正方形は固定合同を持たない（mod 8）。


2)
バニティ・ビットコイン・アドレスの例とイーサリアム版：
バニティ・ビットコインアドレスの例は、特定のパターン（通常は冒頭）を持つカスタムビットコインアドレスを生成することを指します。これは、ブランディング目的、アドレスをより印象的にするため、またはパーソナライズ感を出すためによく使用されます。イーサリアム版は、同じコンセプトでイーサリアムアドレスに適用されます。

3)
O(n)、O(1)、O(log n)を理解する。
これらの表記は、あるアルゴリズムの時間的複雑さを表しています：

O(n)とは、アルゴリズムの実行時間が入力(n)の大きさに対して線形に成長することを意味します。例えば、ソートされていないリストで要素を検索する場合。

O(1)とは、入力の大きさに関係なく、アルゴリズムの実行時間が一定であることを意味します。例えば、配列の中のある要素にインデックスでアクセスする場合。

O(log n)とは、アルゴリズムの実行時間が入力(n)の大きさに対して対数的に成長することを意味します。例えば、ソートされたリストでのバイナリサーチなど。

証明の大きさについて、どれが欲しいですか？
証明の大きさについては、可能な限り小さい複雑さ、つまりO(1)が望まれます。これは、証明の大きさが入力の大きさに依存しないことを意味し、より速く、より効率的になります。
